/*

To Do:

1.  Loop selected MIDI file so it plays over & over.
2.  display

*/










#include <Adafruit_ST7735.h>
#include <Adafruit_GFX.h>
//#include <SoftwareSerial.h>
#include <SdFatUtil.h>
#include <SdFat.h>
#include <SPI.h>
#include <MIDIFile.h>
#include <MIDIHelper.h>



/// Edit for Shield Pinouts!
#define SD_CS    4  // Chip select line for SD card
#define TFT_CS  10  // Chip select line for TFT display
#define TFT_DC   8  // Data/command line for TFT
#define TFT_RST  0  // Reset line for TFT (or connect to +5V)
#define ADA_JOYSTICK 3
Adafruit_ST7735 tft = Adafruit_ST7735(TFT_CS, TFT_DC, TFT_RST);
MIDIFile SMF;  
SdFat	SD;


byte	NoteOff	              = 0x80;	///< Note Off
byte	NoteOn                = 0x90;	///< Note On
byte	AfterTouchPoly        = 0xA0;	///< Polyphonic AfterTouch
byte	ControlChange         = 0xB0;	///< Control Change / Channel Mode
byte	ProgramChange         = 0xC0;	///< Program Change
byte	AfterTouchChannel     = 0xD0;	///< Channel (monophonic) AfterTouch
byte	PitchBend             = 0xE0;	///< Pitch Bend
byte	SystemExclusive       = 0xF0;	///< System Exclusive
byte	TimeCodeQuarterFrame  = 0xF1;	///< System Common - MIDI Time Code Quarter Frame
byte	SongPosition          = 0xF2;	///< System Common - Song Position Pointer
byte	SongSelect            = 0xF3;	///< System Common - Song Select
byte	TuneRequest           = 0xF6;	///< System Common - Tune Request
byte	Clock                 = 0xF8;	///< System Real Time - Timing Clock
byte	Start                 = 0xFA;	///< System Real Time - Start
byte	Continue              = 0xFB;	///< System Real Time - Continue
byte	Stop                  = 0xFC;	///< System Real Time - Stop
byte	ActiveSensing         = 0xFE;	///< System Real Time - Active Sensing
byte	SystemReset           = 0xFF;	///< System Real Time - System Reset
byte	InvalidType           = 0x00;   ///< For notifying errors


byte commandByte;
byte inchannel;
byte inNote;
byte invelocity;

//SoftwareSerial SSerial(2, 3); // RX, TX

long bpm = 120;
long tempo = 1000/(bpm/60);
long prevmillis = 0;
long interval = tempo/24;    //interval is the number of milliseconds defined by tempo formula.

byte oldP = 0;  // a byte to compare to the new Program/patch number //
byte P = 0;  //program or patch number
byte M1 = 0;  //mute for part 1 off
byte M2 = 0;  //mute for part 2 off
byte M3 = 0;  //mute for part 3 off
byte M4 = 0;  //mute for part 4 off
byte M5 = 0;  //mute for part 5 off
byte M6a = 0;  //mute for part 6a off
byte M6b = 0;  //mute for part 6b off
byte M7a = 0;  //mute for part 7a off
byte M7b = 0;  //mute for part 7b off
byte S = 0;   //stop/start bit

#define	WAIT_DELAY	2000	// ms

#define	ARRAY_SIZE(a)	(sizeof(a)/sizeof(a[0]))

const size_t MAX_FILE_COUNT = 500;

const char* FILE_EXT = "MID";

size_t fileCount = 0;

//uint16_t fileIndex[MAX_FILE_COUNT];

// store error strings in flash to save RAM
#define error(s) SD.errorHalt_P(PSTR(s))

//  Joystick directions - Works with our screen rotation (1), yaay
enum { 
  Neutral, Press, Up, Down, Right, Left };
const char*  Buttons[]={
  "Neutral", "Press", "Up", "Down", "Right", "Left" };
#define Neutral 0
#define Press 1
#define Up 2
#define Down 3
#define Right 4
#define Left 5


// Check the joystick position
int CheckJoystick()
{
  int joystickState = analogRead(3);

  if (joystickState < 50) return Down;
  if (joystickState < 150) return Right;
  if (joystickState < 250) return Press;
  if (joystickState < 500) return Up;
  if (joystickState < 650) return Left;
  return Neutral;
 // delay(100);
} 

enum COLORS { 	
  BLACK = 0x0000, BLUE = 0x001F, RED = 0xF800, ORANGE = 0xFA60, GREEN = 0x07E0,
  CYAN = 0x07FF, MAGENTA = 0xF81F, YELLOW = 0xFFE0, GRAY = 0xCCCC, WHITE = 0xFFFF
};

enum arrows { 
  uarr = 0x18, darr = 0x19, larr = 0x1b, rarr = 0x1a, upyr = 0x1e, dpyr = 0x1f, lpyr = 0x11, rpyr = 0x10 };


////////////////////////////////////////////////////////////////////////////////
//  size 1 template:	12345678901234567890123456 <-- if last char is ON 26, \n not req'd; driver inserts it
//static char version[]={"simpleMenu.ino 2013SEP12"};
char textx[64];  // Made buffer big enough to hold two lines of text
char msg[64];
////////////////////////////////////////////////////////////////////////////////
//  Static menu manager
#define MAX_SELECTIONS 5
#define MAX_PROMPT_LEN 20

char  nameFiles[128][20];
char name[20];
String strname = "";
SdFile root;
int filePOS = 0;
int fileIndex = 0;
int listStart = 0;
int maxmidicount;
/////////////////////////
//////////////
void clearFilelist(){
  tft.drawRect(0, 60, 128, 100, BLACK);
  tft.fillRect(0, 60 , 128, 100, BLACK); 
}

//int topfile(int pos, int start, int index){
//
//  int result;
//  pos = filePOS;
//  start = listStart;
//  index = fileIndex;
//
//  if (filePOS>120){
//    result = 7;
//  }
//  else
//  {
//    result = 10; 
//  }
//  return result;
//}


//int maxfile = topfile(filePOS, listStart, fileIndex);
void drawFilelist(int listStart){
  clearFilelist();

  sprintf(msg, "drawFileList\nlistStart: %d\n filePOS: %d\n fileIndex: %d\n", listStart,  filePOS, fileIndex);
  // Serial.print(msg);
  tft.setCursor(0,60);
  int maxfile = maxmidicount;    //topfile(filePOS, listStart, fileIndex);
  // Serial.println(maxfile);
  //for(fileIndex = listStart; fileIndex < (listStart+10); fileIndex++){
  for(fileIndex = listStart; fileIndex < (listStart+10); fileIndex++){
    if (fileIndex == filePOS) {
      tft.setTextColor(GREEN);
    }
    else
    {
      tft.setTextColor(WHITE);
    }
    //  tft.print(fileIndex);  
    //  tft.print(" ");
    //  tft.println(nameFiles[fileIndex]) ;  
    int file2Screen = (fileIndex)%maxfile;  // % means if we go past maxfile it just wraps back to "0"
    tft.print(file2Screen);
    tft.print(" ");
    tft.println(nameFiles[file2Screen]);
  }
  sprintf(msg, "Postdraw\nlistStart: %d\n filePOS: %d\n fileIndex: %d\n", listStart,  filePOS, fileIndex);
  // Serial.print(msg);
}

void IndexFileNames(){
  //char test1[20];
  SD.vwd()->rewind();
  while (root.openNext(SD.vwd(), O_READ)) {
    root.getFilename(name);
    // Serial.println(name);
    root.close();
    strname = name;

    if (strname.endsWith(".MID")    ) {
      fileIndex++;          
      for (int i = 0; i<20; i++){  // 20 because it's the length of the filenames I think

        if (name[i] != 0x00){
          nameFiles[fileIndex][i] = name[i];

        }

      }   
    }     
  }

  tft.setCursor(0,60);
  maxmidicount = fileIndex+1;
}


struct MENUITEM {
  char label[MAX_PROMPT_LEN];
  int datatype;
  void* ptrGlobal;
  int min;
  int max;
  char** ptrGlobalLabels;
}  
;

//float  _voltmod = 0.5;
//float* _voltPtr = &_voltmod;
int 	_clockID = 0;
int* 	_clockPtr = &_clockID;
enum    _clockIDs { 
  INTCLOCK, EXTCLOCK };

int _mapperID=0;
int* _mapperPtr = &_mapperID;
enum _mapperIDs {
  ON, OFF};

static char *_mapperLabels[] = {
  "ON", "OFF"};
static char *_clockLabels[] = { 
  "INT","EXT" };
enum _menuitems { 
  CLOCK_SWITCH, MAPPER_SWITCH };
enum _menuDataTypes { 
  INT, FLOAT, OPTION };

static MENUITEM _mi_list[] ={// type, ptrGlobal, Min,    Max,    			ptrGlobalLabels
  { 
    "MIDI CLOCK:", 		OPTION,	_clockPtr,	0,	 (sizeof(_clockIDs)-1), _clockLabels        }
  ,
  { 
    "MIDI MAPPER:", OPTION, 	_mapperPtr, 0, (sizeof(_mapperIDs)-1), _mapperLabels       }
};


static uint16_t menu_color = WHITE;



struct SELECTION {
  char label[MAX_PROMPT_LEN];
  void(*function) ( int );
  int fn_arg;
}  
;

struct MENU {
  int id;
  char label[MAX_PROMPT_LEN];
  int num_selections;
  SELECTION selection[MAX_SELECTIONS];
} 
;


//  enumerated menu ids must be in order of static MENU menu[], as they are same as array's index
//enum _menus { MAIN_MENU, DEPWD_MENU, BALANCE_MENU };
enum _menus{ 
  MAIN_MENU, FILE_LIST, MAPPINGS, SETTINGS};  // 2/24/14


enum _menu_keys { 
  ADD, EDIT };

static MENU menu[] = {
  { 
    MAIN_MENU, "Main Menu", 4, {
      {
        "MIDI Files", goto_menu, FILE_LIST                  }
      ,  
      {
        "Mappings", goto_menu, MAPPINGS                  }
      ,
      {
        "Settings", goto_menu, SETTINGS                  }
      ,
      {
        "Hide Menu", menu_hide, 0                  } 
    }
  }
  ,
  { 
    FILE_LIST, "MIDI Files", 2, {
      {
        "Select a File", select_midi, 0                  }
      ,  

      {
        "Go Back", goto_menu, MAIN_MENU                  } 
    }
  }
  ,
  { 
    MAPPINGS, "MIDI Mappings Menu", 4, {
      {
        "Add New Mapping", add_mapping, ADD                  }
      ,
      {
        "Edit Mapping", edit_mapping, EDIT                  }
      ,
      {
        "Delete Mapping", delete_mapping, MAIN_MENU                  }
      ,
      {
        "Go Back", goto_menu, MAIN_MENU                  } 
    }
  }
  ,
  { 
    SETTINGS, "Settings", 4, {
      {
        "Map Events On/Off", mapping_onoff, static_cast<int>(MAPPER_SWITCH)                  }
      ,
      {
        "Clock INT/EXT", clock_intext, static_cast<int>(CLOCK_SWITCH)                  }
      ,
      {
        "Tempo", set_tempo, 0                  }
      ,
      {
        "Go Back", goto_menu, MAIN_MENU                  } 
    }
  }
};

MENU * curr_menu = menu;
int menu_enable = 0;
//  curr_selection is the SELECTION array index of the curr_menu
int curr_selection = 0;
void menu_hide( int ){ 
  menu_enable = 0; 
  cls; 
  draw_menu(); 
}



////////////////////////////////////////////////////////////////////////////////
//  Empty, sample action handling example functions
//void sample_func(){
//	tft.setCursor(0,60);	//uint16_t colorsave = tft.getTextColor(); tft.setTextColor( menu_color );
//	tft.print( textx );
//	delay( 1000 );
//	cls();  
////tft.setTextColor( colorsave );
//	draw_menu();
//}
void set_tempo(int key){
  tft.setCursor(0,60);
  tft.println("set tempo");

}

void mapping_onoff(int item){
  cls();
  tft.setTextColor( menu_color );
  sprintf( textx, "\n\n\n\n\nPress %c to exit\nUse %c & %c to adjust\n", larr, uarr, darr );
  tft.print( textx );
  int _x = 1;
  int _y = 3;
  for( uint8_t b = CheckJoystick(); b != Left; b = CheckJoystick() ) {
    void* tempNum;
    int *tempI;
    tft.setCursor(_x,_y);
    sprintf( textx,  "%s:\n", _mi_list[item].label );
    tft.print(textx);
    tft.setTextSize(2);

    if( _mi_list[item].datatype == OPTION || _mi_list[item].datatype == INT ) {
      tempI =  reinterpret_cast<int *>(_mi_list[item].ptrGlobal);
      if( b == Up  )
        *tempI += 1;
      else if( b == Down )
        *tempI -= 1;
      //  ints can implement wrap... might confuse but oh well...
      if( *tempI < _mi_list[item].min ) *tempI = _mi_list[item].max;
      if( *tempI > _mi_list[item].max ) *tempI = _mi_list[item].min;
    }
    if( _mi_list[item].datatype == OPTION )
      sprintf( textx, "%-12.12s\n", _mi_list[item].ptrGlobalLabels[*tempI] );
    if( _mi_list[item].datatype == INT )
      sprintf( textx, "%d\n", *tempI );
    tft.setCursor(0,20);
    tft.drawRect(0, 20, 35, 16, BLACK);
    tft.fillRect(0, 20 , 35, 16, BLACK);
    tft.print(textx);  //prints the ON or OFF
    tft.setTextSize(1);
    if( _mi_list[item].datatype == OPTION ) {
      sprintf( textx, "\n\noption index = %d, max = %d\n", *tempI, _mi_list[item].max );
      tft.setCursor(0,60);
      tft.print(textx);
    }
    if( b ) // control repeat speed
      delay(250);
  }
  //tft.setTextColor( colorsave );
  cls();
  draw_menu();


  //////////////////////////////////////////////////////////////////////////////////////////////////
}

void clock_intext (int key){
  tft.setCursor(0,60);
  tft.println("set the midi clock to int or ext");

}


void select_midi(int key){

  tft.setCursor(0,60);

  drawFilelist(listStart);

  for( uint8_t b = CheckJoystick(); b != Left   ; b = CheckJoystick() ) {
    if (b == Down){
      /////////////////////
      //     if (filePOS<127){
      //        if (filePOS>=(listStart+9) ){
      //          filePOS++;
      //          //listStart = filePOS;   
      //       listStart = listStart+1   ;
      //          drawFilelist();
      //          Serial.println("new page");
      //        }
      //        else
      //        {
      //          filePOS++;
      //          drawFilelist();
      //          Serial.println("goin down");
      //        }
      //
      //     }

      filePOS = (filePOS++)%maxmidicount;  //wraps back to 0 if  = maximidicount
      listStart = filePOS;    
      drawFilelist(listStart);
      sprintf(msg, "listStart: %d\n filePOS: %d\n fileIndex: %d\n", listStart,  filePOS, fileIndex);
      //  Serial.print(msg);
      //sychronize the MIDI file with the program change
            sendChangeControl(99,05,10);
        sendChangeControl(98,107,10);
        sendChangeControl(06,0,10);
      sendChangeControl(99,05,10);
        sendChangeControl(98,108,10);
        sendChangeControl(06,0,10);
        sendProgramChange(filePOS,10);
        P=filePOS;
      
      
      

    }
    //////////////////////////
    else  if (b==Up){
      //if (filePOS>1){
      //      if (filePOS<=(listStart)){
      //        filePOS--;
      //       // listStart = filePOS-9;
      //       listStart = listStart-1;
      //        drawFilelist();
      //      }
      //      else
      //      {
      //        filePOS--;
      //        drawFilelist();
      //      }
      //
      //
      //    }

      filePOS = (filePOS+maxmidicount-1)%maxmidicount;  //wraps back to maximidicount if <0
      listStart = filePOS;      
      drawFilelist(listStart);

      sprintf(msg, "listStart: %d\n filePOS: %d\n fileIndex: %d\n", listStart,  filePOS, fileIndex);
      // Serial.print(msg);
      
      //try to sync the Program changes with MIDI filesj
             sendChangeControl(99,05,10);
        sendChangeControl(98,107,10);
        sendChangeControl(06,0,10);
        sendChangeControl(99,05,10);
        sendChangeControl(98,108,10);
        sendChangeControl(06,0,10);
        sendProgramChange(filePOS,10);
        P=filePOS;
    }
    //
  }
  cls();
  draw_menu();
}

//this prints all the files names, but I only want 10 at a time, for all files (scrollable list).

//}

void add_mapping(int key){
  tft.setCursor(0,60);
  // sprintf(text,  "%s %d\n\nOMG you're RICH!", __FUNCTION__, key );
  tft.println("add a midi mapping");
}

void edit_mapping(int key){
  tft.setCursor(0,60);
  tft.println("select a mapping to edit"); 
}

void delete_mapping(int key){
  tft.setCursor(0,60);
  tft.println("select a mapping to delete");
}

////////////////////////////////////////////////////////////////////////////////
// Edit menu controller with cheesey type-dependent special cases
//void menu_edit( int key ){
//	//sprintf( text, "%s %d\n\nOMG you're RICH!", __FUNCTION__, key );
//	sample_func();
//}

////////////////////////////////////////////////////////////////////////////////
// Set & display active menu
void goto_menu ( ) {
  //  a_menu is working copy of curr_menu, which will get reset to our parent
  static MENU *a_menu = curr_menu;
  //	Create a selection pointer for convenience
  //  the LAST selection in a menu must be to "go up" a menu
  static SELECTION *selptr = &a_menu->selection[ curr_selection ];
  curr_menu = &menu[selptr->fn_arg ];
  curr_selection=0;
  cls();
  draw_menu();
  return;
}
void goto_menu ( int newmenu ) {
  curr_menu = &menu[newmenu];
  curr_selection=0;
  cls();
  draw_menu();
  return;
}


////////////////////////////////////////////////////////////////////////////////
bool doMenu( void ){
  //uint8_t b = checkJoystick();

  uint8_t b = CheckJoystick();
  if( b == Neutral ){
    return false;   //  user input didn't happen
  }

  //  enable menu if up, else ignore input & return  ---------------------------------------
  if( ! menu_enable ) {
    if( b == Up ) {
      menu_enable = 1;
      curr_selection = 0;   //  start with top item as selected
      cls();
      draw_menu();
    }
    return 0;
  }

  //-----------------------------------------------------------------------------------------
  SELECTION *selptr = &curr_menu->selection[ curr_selection ];
  tft.setCursor(0,10);
  // const char* Buttons[]={"Neutral", "Press", "Up", "Down", "Right", "Left" };
  if( b == Up ) {
    if(curr_selection > 0)
      curr_selection--;
    else    //  wrap around
    curr_selection = curr_menu->num_selections-1;
  } 
  else if( b == Down ) {
    if(curr_selection < curr_menu->num_selections-1 )
      curr_selection++;
    else
      curr_selection=0;
  } 
  else if( b == Left ) {    //  back out to higher menu
    menu_parent();
  } 
  else if( b == Right || b == Press ) {
    // curr_menu->selection[curr_selection].function();
    selptr->function( selptr->fn_arg );
  }
  if( b == Up || b == Down )
    draw_menu( );
  return true;    //  user input happened
}
////////////////////////////////////////////////////////////////////////////////
//  Finds parent of current menu and resets curr_menu to it and draws menu
void menu_parent( ){
  curr_selection=0;
  //  already at top of menu, so hide it. &menu[0] used as is more obvious than just 'menu'
  if( curr_menu == &menu[0] && menu_enable ) {
    menu_enable = false;
  } 
  else {
    //  a_menu is working copy of curr_menu, which will get reset to our parent
    MENU *a_menu = curr_menu;
    //	Create a selection pointer for convenience
    //  the LAST selection in a menu must be to "go up" a menu
    static int num_menus=sizeof(_menus);
    SELECTION *selptr = &a_menu->selection[ a_menu->num_selections - 1 ];
    for( int menuidx = 0; menuidx < num_menus ; menuidx++ ) {
      if( selptr->fn_arg == menu[menuidx].id ) {
        curr_menu=&menu[menuidx];
        curr_selection=0;
        break;
      }
    }
  }
  cls();
  draw_menu();
}
////////////////////////////////////////////////////////////////////////////////
//  displays the currently selected menu (or uarr for menu if not enabled)
void draw_menu( ){
  String TempoString = "Tempo: "; 

  String String3;  // a string so I can concat tempo char and tempo bpm
  String3 = TempoString + bpm; 
  if( ! menu_enable ) {
    cls();

    sprintf( textx, "%c for menu", uarr );
    tft.print( textx );

    tft.setCursor(1, 20);
    tft.setTextColor(GREEN);
    tft.print("File: ");
    tft.println(nameFiles[filePOS]);
    tft.setCursor(1,50);
    tft.setTextColor(RED);
    tft.setTextSize(2);
    tft.println(String3);


    tft.setTextSize(1);
    //guiFooter();
    return;

  }
  //	//uint16_t colorsave = tft.getTextColor();
  tft.setTextColor( menu_color );
  tft.setCursor(0, 2);
  //Serial.println(freeMemory());
  //	//  magic number alert! set %-20.20s to same value as MAX_PROMPT_LEN

  sprintf( textx, "%-20.20s\n", curr_menu->label );
  tft.print(textx);
  int selection_num = 0;
  //	// Loop through the actual number of selections in THIS menu
  for(selection_num=0; selection_num < curr_menu->num_selections; selection_num++)
  {
    //		// Create a pointer for convenience
    SELECTION *selptr = &curr_menu->selection[selection_num];
    //		//	If this is the "active" menu selection (determine by referencing the global
    //		//	variable 'curr_selection' then draw it in inverse text.
    if (selection_num == curr_selection)
      tft.setTextColor(BLUE);
    //		// Print the prompt string
    //tft.setCursor(selection_num + MENU_INDENT_Y, MENU_INDENT_X);
    sprintf( textx, "  %-20.20s\n", selptr->label );
    tft.print(textx);
    //		// Turn inverse back off if need be
    if (selection_num == curr_selection)
      tft.setTextColor(RED);
  }

  tft.setTextColor( WHITE );

}
////////////////////////////////////////////////////////////////////////////////
void setup(){
  //SSerial.begin(31250);
  Serial.begin(31250);

  pinMode(A5, OUTPUT);      // sets the digital pin as output, D19 on Rugged circuits MIDI shield = A5 on Mega.
  digitalWrite(A5, HIGH);
  tft.initR( INITR_BLACKTAB );    //  "tab color" from screen protector; there's RED and GREEN, too.


  tft.fillScreen(BLACK);
  tft.setTextSize(1); //  1 = 5x8, 2 = 10x16; chars leave blank pixel on bottom
  tft.println("TFT Setup Completed");
  tft.println("SD Init...");
  // Initialise SD
  // if (!SD.begin(SD_CS, SPI_HALF_SPEED)) SD.initErrorHalt();
  if (!SD.begin(SD_CS, SPI_HALF_SPEED))
  {
    // Serial.print("\nSD init fail!");
    tft.println("SD init fail!");
    return;
  }
  tft.println("SD Init completed");


  draw_menu();
  IndexFileNames();   //get a count of the MID files
  SMF.begin(&SD);
  SMF.setMidiHandler(midiCallback);
}

////////////////////////////////////////////////////////////////////////////////
//  clearscreen helper for tft
void cls() {
  tft.fillScreen(BLACK);
  tft.setCursor(0, 2);
}



////////////////////////////////////////////////////////////////////////////////
void loop() {
  Sync();
  CheckMIDI();
  if( doMenu() ){

    //		//  something happened with joystick, an update() action could be called here
  }
  //Play();
}

void goodnotes(){
  for (byte inNote = 60; inNote <64; inNote++){
    sendNoteOn(0x90, inNote, 120);
    delay(100);
    sendNoteOn(0x90, inNote, 0);
    delay(100);
  }
}
void sendNoteOn(byte cmd, byte inNote, byte invelocity){
  Serial.write(cmd);
  Serial.write(inNote);
  Serial.write(invelocity);
}
void Play(){
  //play the currently selected midi file *********************************************************
   
while (S == 1)
{
  int  err = -1;
  //  for (uint8_t i=0; i<ARRAY_SIZE(tuneList); i++)
  //{
  // reset LEDs
  // use the next file name and play it
  //    SMF.setFilename(tuneList[i]);
 // SMF.setFilename(nameFiles[filePOS]);  ///do not move this
 
 if (P == oldP) {
   SMF.setFilename(nameFiles[filePOS]);
   tft.setTextColor(GREEN);
    tft.setCursor(5, 100);
      tft.println(nameFiles[filePOS]);
      tft.println(P);
 }
 else
 {
   SMF.setFilename(nameFiles[P]);
  oldP = P;
  filePOS= P;
  draw_menu();
     tft.setCursor(5, 120);
     tft.setTextColor(RED);
      tft.println(nameFiles[filePOS]);
      tft.println(P); 
      tft.setCursor(10, 120);
      tft.print(oldP);
      
      
 }
   err = SMF.load();
  //
  if (err != -1)
    {
      tft.setCursor(5, 140);
      tft.print("MIDI File Load Error");
      break;
  }
  else
  {
    // play/loop the file
    while (!SMF.isEOF())
    {
      if (SMF.getNextEvent())
        Sync();
      CheckMIDI();
      SMF.setTempo(bpm);       
    }
   SMF.close();
     SMF.restart();
   }
   draw_menu();
  } //while S == 1 closing bracket
}

void CheckMIDI(){
  //  Serial.println("checking midi");
  // do{

  //  if (Serial.available()>0){
  //Serial.println("Serial available

  while (Serial.available() > 2){
    byte indata = Serial.read();
    if (indata >=144 && indata <= 159){          //144 is simply 0x90 or MIDI noteOn, there are 15 (0-15) possible channels so the max is 159 or 0x9F. I only care about NoteOn status messages.
      // Serial.println("NoteOn rxd");
      commandByte = indata;//read first byte
      inNote = Serial.read();//read next byte
      invelocity = Serial.read();//read final byte
      inchannel = (commandByte - 144);
      HandleNoteOn(commandByte, inNote, invelocity);
    }
    //}      // this is the end of the 'if(Serial.available) line...///
    //}
    //while (Serial.available() > 2);//when at least three bytes available
  }  //new while end bracket
}

void Sync(){

  unsigned long currentMillis = millis();
  if(currentMillis - prevmillis > interval) {
    // save the last time.
    prevmillis = currentMillis;
    // MIDI.sendRealTime(midi::Clock);   MIDI 4.0 CONVENTION
    Serial.write(Clock); 
  }
}

void midiSilence(void)
// Turn everything off on every channel.
// Some midi files are badly behaved and leave notes hanging, so between songs turn
// off all the notes and sound
{
  midi_event	ev;

  // All sound off
  // When All Sound Off is received all oscillators will turn off, and their volume
  // envelopes are set to zero as soon as possible.
  ev.size = 0;
  ev.data[ev.size++] = 0xb0;
  ev.data[ev.size++] = 120;
  ev.data[ev.size++] = 0;

  for (ev.channel = 0; ev.channel < 16; ev.channel++)
    midiCallback(&ev);
}


void midiCallback(midi_event *pev)
// Called by the MIDIFile library when a file event needs to be processed
// thru the midi communications interface.
// This callback is set up in the setup() function.
{

  if ((pev->data[0] >= 0x80) && (pev->data[0] <= 0xe0))
  {
    Serial.write(pev->data[0] | pev->channel);
    Serial.write(&pev->data[1], pev->size-1);

  }
  else
  {
    Serial.write(pev->data, pev->size);

  }


  //  DEBUG("\nM T");
  //  DEBUG(pev->track);
  //  DEBUG(":  Ch ");
  //  DEBUG(pev->channel+1);
  //  DEBUG(" Data ");
  //  for (uint8_t i=0; i<pev->size; i++)
  //  {
  //	DEBUGX(pev->data[i]);
  //    DEBUG(' ');
  //  }
}



void sendProgramChange(byte Program, byte inchannel){
  Serial.write(P);
  Serial.write(inchannel);
}

void sendChangeControl(byte ControlNumber,byte ControlValue,byte inchannel){
  Serial.write(ControlChange);
  Serial.write(ControlNumber);
  Serial.write(ControlValue);
  inchannel = inchannel;
  Serial.write(inchannel);
}

void sendNoteOff(byte inNote, byte invelocity, byte inchannel){
  Serial.write(NoteOff);
  Serial.write(inNote);
  Serial.write(invelocity);
  Serial.write(inchannel);
}
void checkdata(){
  //Serial.println(commandByte);
  //Serial.println(inNote);
  //Serial.println(invelocity);
}

void HandleNoteOn (byte commandByte, byte inNote, byte invelocity){
  //if note X is sent, send program change control to go up
  //todo: 

  if (invelocity>0){ //needs to be greater than zero, not equal to,
    switch (inNote) {
    case 12: //note value of A#3 or 0x3a    
      if (S == 0){
        S++;
        // MIDI.sendRealTime(Start);
        Serial.write(Start);
        Play();  //
      }
      else
      {
        S--;
        // MIDI.sendRealTime(Stop);
        Serial.write(Stop);  
        SMF.close(); ///probably working, but the player just moves to the next song...
        ////        MIDI.sendSongPosition(0);
        midiSilence();   //123	01111011	7B	[Channel Mode Message] All Notes Off	0
      }
      break;
    case 13: //note value of C4  or 0x3C, handles program change 'up'
      if (P == 127){    //this notes that the program is at the highest of 127 and needs reset to 0
        P=0;
        sendChangeControl(99,05,10);  //double check these control change msgs
        sendChangeControl(98,107,10);
        sendChangeControl(06,0,10);
        sendChangeControl(99,05,10);
        sendChangeControl(98,108,10);
        sendChangeControl(06,0,10);
        sendProgramChange(P,10);
        
          draw_menu();
     tft.setCursor(5, 120);
     tft.setTextColor(RED);
     tft.println(nameFiles[P]);
      tft.println(P);
        
       // filePOS=P;
       
      }
      else
      {
        P++;
        sendChangeControl(99,05,10);
        sendChangeControl(98,107,10);
        sendChangeControl(06,0,10);
        sendChangeControl(99,05,10);
        sendChangeControl(98,108,10);
        sendChangeControl(06,0,10);
        sendProgramChange(P,10);
//filePOS=P;

         draw_menu();
     tft.setCursor(5, 120);
     tft.setTextColor(RED);
     tft.println(nameFiles[P]);
      tft.println(P);
      }
      break;
    case 14: // note value of D4  or 0x3E, handles program change 'down'.
      if (P== 0){
        P=127;
        sendChangeControl(99,05,10);
        sendChangeControl(98,107,10);
        sendChangeControl(06,0,10);
        sendChangeControl(99,05,10);
        sendChangeControl(98,108,10);
        sendChangeControl(06,0,10);
        // MIDI.sendProgramChange(P,10); 
  //      filePOS=P;
  
            draw_menu();
     tft.setCursor(5, 120);
     tft.setTextColor(RED);
     tft.println(nameFiles[P]);
      tft.println(P);
     
      }
      else 
      {
        P--;
        sendChangeControl(99,05,10);
        sendChangeControl(98,107,10);
        sendChangeControl(06,0,10);
        sendChangeControl(99,05,10);
        sendChangeControl(98,108,10);
        sendChangeControl(06,0,10);
        //  MIDI.sendProgramChange(P,10);
    //    filePOS=P;
    
              draw_menu();
     tft.setCursor(5, 120);
     tft.setTextColor(RED);
     tft.println(nameFiles[P]);
      tft.println(P);

      }
      break;
    case 15:		//part 1 mute, M variable tells us if it's muted already;  all these mutes actually set the volume to zero, uses the volume NRPNs!
      if (M1==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,1,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M1=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,1,10);
        sendChangeControl(06,120,10);
        M1=0;
      }

      break;
    case 16:
      if (M2==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,9,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 2
        //need to toggle it
        M2=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,9,10);
        sendChangeControl(06,120,10);
        M2=0;
      }
      break;
    case 17:   //mute for part 3
      if (M3==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,17,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 3
        //need to toggle it
        M3=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,17,10);
        sendChangeControl(06,120,10);
        M3=0;
      }
      break;
    case 18:
      if (M4==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,25,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M4=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,25,10);
        sendChangeControl(06,120,10);
        M4=0;
      }
      break;
    case 19:
      if (M5==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,33,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M5=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,33,10);
        sendChangeControl(06,120,10);
        M5=0;
      }
      break;
    case 20:
      if (M6a==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,41,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M6a=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,41,10);
        sendChangeControl(06,120,10);
        M6a=0;
      }
      break;
    case 21:
      if (M6b==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,49,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M6b=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,49,10);
        sendChangeControl(06,120,10);
        M6b=0;
      }
      break;
    case 22:
      if (M7a==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,57,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M7a=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,57,10);
        sendChangeControl(06,120,10);
        M7a=0;
      }
      break;
    case 23:
      if (M7b==0) {
        sendChangeControl(99,5,10);
        sendChangeControl(98,65,10);
        sendChangeControl(06,0,10);  //sets level to zero, for part 1
        //need to toggle it
        M7b=1;
      }
      else {
        sendChangeControl(99,5,10);
        sendChangeControl(98,65,10);
        sendChangeControl(06,120,10);
        M7b=0;
      }
      break;


    } //end of switch (note)  



  }

  else{
    switch(inNote){
    case 12:
      sendNoteOff(12,0,10);
      break;
    case 13:
      sendNoteOff(13,0,10);
      break;
    case 14:
      sendNoteOff(14,0, 10);
      break;   
    case 15:
      sendNoteOff(15,0, 10);
      break;      
    case 16:
      sendNoteOff(16,0, 10);
      break;      
    case 17:
      sendNoteOff(17,0, 10);
      break;      
    case 18:
      sendNoteOff(18,0, 10);
      break;      
    case 19:
      sendNoteOff(19,0, 10);
      break;      
    case 20:
      sendNoteOff(21,0, 10);
      break;   
    case 21:
      sendNoteOff(21,0, 10);
      break;      
    case 22:
      sendNoteOff(22,0, 10);
      break;     
    case 23:
      sendNoteOff(23,0, 10);
      break;            

    }
  }

}



